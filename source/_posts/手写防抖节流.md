---
title: 手写防抖节流
date: 2023-10-10 17:19:08
categories: 
- 手写  
tags:
- 防抖
- 节流      
---
## 节流（Throttle）： 如果您希望限制按钮点击事件的触发频率，以防止用户频繁点击按钮，或者您希望在一段时间内以固定的频率执行按钮点击事件，那么节流是更合适的选择。使用节流，您可以确保按钮点击事件每隔一定的时间间隔执行一次，防止事件处理函数过于频繁地被调用。

```tsx
function throttle(func, delay) {
  let throttled = false;

  return function () {
    if (!throttled) {
      func.apply(this, arguments);
      throttled = true;
      setTimeout(function () {
        throttled = false;
      }, delay);
    }
  };
}

// 用法示例
function handleClick() {
  // 在此处处理按钮点击事件
}

const throttledClick = throttle(handleClick, 1000); // 设置1秒的延迟

// 在按钮点击时触发处理函数
buttonElement.addEventListener('click', throttledClick);

```

优化节流（Throttle）方法的一个常见做法是使用时间戳（timestamp）来判断是否应该执行事件处理函数。这种优化方式被称为“时间戳节流”。

在时间戳节流中，我们记录上一次执行事件处理函数的时间戳，并在每次事件触发时，检查当前时间戳与上一次执行时间戳的差值是否超过设定的时间间隔。如果超过时间间隔，就执行事件处理函数，并更新上一次执行的时间戳；如果未超过时间间隔，则不执行事件处理函数。

以下是使用时间戳节流的示例代码：

```javascript
function throttle(func, delay) {
  let lastExecTime = 0;

  return function() {
    const context = this;
    const args = arguments;
    const currentTime = Date.now();

    if (currentTime - lastExecTime >= delay) {
      func.apply(context, args);
      lastExecTime = currentTime;
    }
  };
}

// 用法示例
function handleScroll() {
  // 在此处处理滚动事件逻辑
}

const throttledScroll = throttle(handleScroll, 300); // 设置300毫秒的延迟

// 在滚动时触发处理函数
window.addEventListener('scroll', throttledScroll);
```

在上述示例代码中，我们使用了 `Date.now()` 来获取当前的时间戳，与上一次执行事件处理函数的时间戳进行比较。如果时间间隔超过设定的 `delay` 值，就执行事件处理函数，并更新 `lastExecTime` 为当前时间戳。这样可以确保在指定时间间隔内只执行一次事件处理函数。

时间戳节流相比之前的定时器实现，避免了在时间间隔内重复设置和清除定时器的开销，从而提高了性能和响应性。它是一种更优化的节流方法，特别适用于处理高频率触发的事件。

## 防抖（Debounce）： 如果您希望在用户点击按钮后，等待一段时间，在此期间如果用户再次点击按钮，则会重置等待时间，直到用户停止点击按钮后，再执行按钮点击事件的处理函数，那么防抖是更合适的选择。使用防抖，您可以确保只有用户停止点击按钮一段时间后，才会执行一次按钮点击事件的处理函数。

```tsx
function debounce(func, delay) {
  let timeoutId;

  return function () {
    const context = this;
    const args = arguments;

    clearTimeout(timeoutId);
    timeoutId = setTimeout(function () {
      func.apply(context, args);
    }, delay);
  };
}

// 用法示例
function handleClick() {
  // 在此处处理按钮点击事件
}

const debouncedClick = debounce(handleClick, 1000); // 设置1秒的延迟

// 在按钮点击时触发处理函数
buttonElement.addEventListener('click', debouncedClick);

```

您想要实现首次立即执行的防抖，即在第一次触发事件时立即执行一次事件处理函数，然后再按照设定的延迟执行后续的事件处理。为了实现这个功能，您可以在函数内部使用一个变量来判断是否是首次触发事件，并在首次触发时立即执行事件处理函数。

以下是实现首次立即执行的防抖的示例代码：

```javascript
function debounce(func, delay, immediate) {
  let timeoutId;

  return function() {
    const context = this;
    const args = arguments;

    // 清除之前的定时器
    clearTimeout(timeoutId);

    if (immediate) {
      const callNow = !timeoutId; // 判断是否是首次触发
      timeoutId = setTimeout(function() {
        timeoutId = null; // 重置定时器
      }, delay);

      if (callNow) {
        func.apply(context, args); // 首次触发时立即执行
      }
    } else {
      timeoutId = setTimeout(function() {
        func.apply(context, args);
      }, delay);
    }
  };
}

// 用法示例
function handleInput() {
  // 在此处处理输入事件逻辑
}

const debouncedInput = debounce(handleInput, 500, true); // 设置500毫秒的延迟，并立即执行首次触发

// 在输入框输入时触发处理函数
inputElement.addEventListener('input', debouncedInput);
```

在上述示例代码中，我们新增了一个 `immediate` 参数，用于判断是否首次触发时立即执行事件处理函数。如果 `immediate` 参数为 `true`，则在第一次触发事件时会立即执行一次事件处理函数，并设置一个延迟后续执行的定时器。在后续的触发事件中，会清除定时器并再次设置新的定时器，直到设定的延迟时间后执行事件处理函数。

通过这种方式，您可以实现首次立即执行的防抖，从而更好地控制函数的执行频率。